import {
  require_jsx_runtime
} from "./chunk-VFONIU3E.js";
import {
  require_react_dom
} from "./chunk-F6F7MSRS.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-KVZCIEWH.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object3) {
          if (typeof object3 === "object" && object3 !== null) {
            var $$typeof = object3.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object3.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object3) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object3) || typeOf(object3) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object3) {
          return typeOf(object3) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object3) {
          return typeOf(object3) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object3) {
          return typeOf(object3) === REACT_PROVIDER_TYPE;
        }
        function isElement(object3) {
          return typeof object3 === "object" && object3 !== null && object3.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object3) {
          return typeOf(object3) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object3) {
          return typeOf(object3) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object3) {
          return typeOf(object3) === REACT_LAZY_TYPE;
        }
        function isMemo(object3) {
          return typeOf(object3) === REACT_MEMO_TYPE;
        }
        function isPortal(object3) {
          return typeOf(object3) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object3) {
          return typeOf(object3) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object3) {
          return typeOf(object3) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object3) {
          return typeOf(object3) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@szhsin/react-menu/dist/es/_virtual/_rollupPluginBabelHelpers.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/@szhsin/react-menu/dist/es/components/MenuButton.js
var import_react3 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@szhsin/react-menu/dist/es/utils/utils.js
var import_react_dom = __toESM(require_react_dom());
var isMenuOpen = function isMenuOpen2(state) {
  return !!state && state[0] === "o";
};
var batchedUpdates = import_react_dom.unstable_batchedUpdates || function(callback) {
  return callback();
};
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(key) {
    return obj[key];
  });
};
var floatEqual = function floatEqual2(a, b, diff) {
  if (diff === void 0) {
    diff = 1e-4;
  }
  return Math.abs(a - b) < diff;
};
var getTransition = function getTransition2(transition, name) {
  return transition === true || !!(transition && transition[name]);
};
var safeCall = function safeCall2(fn, arg) {
  return typeof fn === "function" ? fn(arg) : fn;
};
var internalKey = "_szhsinMenu";
var getName = function getName2(component) {
  return component[internalKey];
};
var defineName = function defineName2(name, component) {
  return Object.defineProperty(component, internalKey, {
    value: name
  });
};
var mergeProps = function mergeProps2(target, source) {
  source && Object.keys(source).forEach(function(key) {
    var targetProp = target[key];
    var sourceProp = source[key];
    if (typeof sourceProp === "function" && targetProp) {
      target[key] = function() {
        sourceProp.apply(void 0, arguments);
        targetProp.apply(void 0, arguments);
      };
    } else {
      target[key] = sourceProp;
    }
  });
  return target;
};
var parsePadding = function parsePadding2(paddingStr) {
  if (typeof paddingStr !== "string")
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  var padding = paddingStr.trim().split(/\s+/, 4).map(parseFloat);
  var top = !isNaN(padding[0]) ? padding[0] : 0;
  var right = !isNaN(padding[1]) ? padding[1] : top;
  return {
    top,
    right,
    bottom: !isNaN(padding[2]) ? padding[2] : top,
    left: !isNaN(padding[3]) ? padding[3] : right
  };
};
var getScrollAncestor = function getScrollAncestor2(node3) {
  while (node3) {
    node3 = node3.parentNode;
    if (!node3 || node3 === document.body)
      return;
    var _getComputedStyle = getComputedStyle(node3), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX))
      return node3;
  }
};
function commonProps(isDisabled, isHovering) {
  return {
    "aria-disabled": isDisabled || void 0,
    tabIndex: isHovering ? 0 : -1
  };
}
function indexOfNode(nodeList, node3) {
  for (var i = 0; i < nodeList.length; i++) {
    if (nodeList[i] === node3)
      return i;
  }
  return -1;
}

// node_modules/@szhsin/react-menu/dist/es/hooks/useBEM.js
var import_react = __toESM(require_react());
var useBEM = function useBEM2(_ref) {
  var block = _ref.block, element2 = _ref.element, modifiers = _ref.modifiers, className = _ref.className;
  return (0, import_react.useMemo)(function() {
    var blockElement = element2 ? block + "__" + element2 : block;
    var classString = blockElement;
    modifiers && Object.keys(modifiers).forEach(function(name) {
      var value = modifiers[name];
      if (value)
        classString += " " + blockElement + "--" + (value === true ? name : name + "-" + value);
    });
    var expandedClassName = typeof className === "function" ? className(modifiers) : className;
    if (typeof expandedClassName === "string") {
      expandedClassName = expandedClassName.trim();
      if (expandedClassName)
        classString += " " + expandedClassName;
    }
    return classString;
  }, [block, element2, modifiers, className]);
};

// node_modules/@szhsin/react-menu/dist/es/utils/propTypes.js
var import_prop_types = __toESM(require_prop_types());
var stylePropTypes = function stylePropTypes2(name) {
  var _ref;
  return _ref = {}, _ref[name ? name + "ClassName" : "className"] = (0, import_prop_types.oneOfType)([import_prop_types.string, import_prop_types.func]), _ref;
};
var menuPropTypes = _extends({
  className: import_prop_types.string
}, stylePropTypes("menu"), stylePropTypes("arrow"), {
  menuStyle: import_prop_types.object,
  arrowStyle: import_prop_types.object,
  arrow: import_prop_types.bool,
  setDownOverflow: import_prop_types.bool,
  offsetX: import_prop_types.number,
  offsetY: import_prop_types.number,
  align: (0, import_prop_types.oneOf)(["start", "center", "end"]),
  direction: (0, import_prop_types.oneOf)(["left", "right", "top", "bottom"]),
  position: (0, import_prop_types.oneOf)(["auto", "anchor", "initial"]),
  overflow: (0, import_prop_types.oneOf)(["auto", "visible", "hidden"])
});
var rootMenuPropTypes = _extends({}, menuPropTypes, {
  containerProps: import_prop_types.object,
  initialMounted: import_prop_types.bool,
  unmountOnClose: import_prop_types.bool,
  transition: (0, import_prop_types.oneOfType)([import_prop_types.bool, (0, import_prop_types.exact)({
    open: import_prop_types.bool,
    close: import_prop_types.bool,
    item: import_prop_types.bool
  })]),
  transitionTimeout: import_prop_types.number,
  boundingBoxRef: import_prop_types.object,
  boundingBoxPadding: import_prop_types.string,
  reposition: (0, import_prop_types.oneOf)(["auto", "initial"]),
  repositionFlag: (0, import_prop_types.oneOfType)([import_prop_types.string, import_prop_types.number]),
  viewScroll: (0, import_prop_types.oneOf)(["auto", "close", "initial"]),
  submenuOpenDelay: import_prop_types.number,
  submenuCloseDelay: import_prop_types.number,
  portal: (0, import_prop_types.oneOfType)([import_prop_types.bool, (0, import_prop_types.exact)({
    target: import_prop_types.object,
    stablePosition: import_prop_types.bool
  })]),
  theming: import_prop_types.string,
  onItemClick: import_prop_types.func
});
var uncontrolledMenuPropTypes = {
  instanceRef: (0, import_prop_types.oneOfType)([import_prop_types.object, import_prop_types.func]),
  onMenuChange: import_prop_types.func
};

// node_modules/@szhsin/react-menu/dist/es/utils/constants.js
var import_react2 = __toESM(require_react());
var menuContainerClass = "szh-menu-container";
var menuClass = "szh-menu";
var menuButtonClass = "szh-menu-button";
var menuArrowClass = "arrow";
var menuItemClass = "item";
var menuDividerClass = "divider";
var menuHeaderClass = "header";
var menuGroupClass = "group";
var subMenuClass = "submenu";
var radioGroupClass = "radio-group";
var HoverItemContext = (0, import_react2.createContext)();
var MenuListItemContext = (0, import_react2.createContext)({});
var MenuListContext = (0, import_react2.createContext)({});
var EventHandlersContext = (0, import_react2.createContext)({});
var RadioGroupContext = (0, import_react2.createContext)({});
var SettingsContext = (0, import_react2.createContext)({});
var ItemSettingsContext = (0, import_react2.createContext)({});
var Keys = Object.freeze({
  ENTER: "Enter",
  ESC: "Escape",
  SPACE: " ",
  HOME: "Home",
  END: "End",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  UP: "ArrowUp",
  DOWN: "ArrowDown"
});
var HoverActionTypes = Object.freeze({
  RESET: 0,
  SET: 1,
  UNSET: 2,
  INCREASE: 3,
  DECREASE: 4,
  FIRST: 5,
  LAST: 6,
  SET_INDEX: 7
});
var CloseReason = Object.freeze({
  CLICK: "click",
  CANCEL: "cancel",
  BLUR: "blur",
  SCROLL: "scroll"
});
var FocusPositions = Object.freeze({
  FIRST: "first",
  LAST: "last"
});
var MenuStateMap = Object.freeze({
  entering: "opening",
  entered: "open",
  exiting: "closing",
  exited: "closed"
});

// node_modules/@szhsin/react-menu/dist/es/components/MenuButton.js
var _excluded = ["className", "isOpen", "disabled", "children"];
var MenuButton = defineName("MenuButton", (0, import_react3.forwardRef)(function MenuButton2(_ref, ref) {
  var className = _ref.className, isOpen = _ref.isOpen, disabled = _ref.disabled, children = _ref.children, restProps = _objectWithoutPropertiesLoose(_ref, _excluded);
  var modifiers = (0, import_react3.useMemo)(function() {
    return {
      open: isOpen
    };
  }, [isOpen]);
  return (0, import_jsx_runtime.jsx)("button", _extends({
    "aria-haspopup": true,
    "aria-expanded": isOpen,
    "aria-disabled": disabled || void 0,
    type: "button",
    disabled
  }, restProps, {
    ref,
    className: useBEM({
      block: menuButtonClass,
      modifiers,
      className
    }),
    children
  }));
}));
true ? MenuButton.propTypes = _extends({}, stylePropTypes(), {
  isOpen: import_prop_types2.bool,
  disabled: import_prop_types2.bool
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/Menu.js
var import_react12 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// node_modules/@szhsin/react-menu/dist/es/components/ControlledMenu.js
var import_react8 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@szhsin/react-menu/dist/es/components/MenuList.js
var import_react7 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@szhsin/react-menu/dist/es/hooks/useItems.js
var import_react4 = __toESM(require_react());
var useItems = function useItems2(menuRef, focusRef) {
  var _useState = (0, import_react4.useState)(), hoverItem = _useState[0], setHoverItem = _useState[1];
  var stateRef = (0, import_react4.useRef)({
    items: [],
    hoverIndex: -1,
    sorted: false
  });
  var mutableState = stateRef.current;
  var updateItems = (0, import_react4.useCallback)(function(item, isMounted) {
    var items = mutableState.items;
    if (!item) {
      mutableState.items = [];
    } else if (isMounted) {
      items.push(item);
    } else {
      var index = items.indexOf(item);
      if (index > -1) {
        items.splice(index, 1);
        if (item.contains(document.activeElement)) {
          focusRef.current.focus();
          setHoverItem();
        }
      }
    }
    mutableState.hoverIndex = -1;
    mutableState.sorted = false;
  }, [mutableState, focusRef]);
  var dispatch = (0, import_react4.useCallback)(function(actionType, item, nextIndex) {
    var items = mutableState.items, hoverIndex = mutableState.hoverIndex;
    var sortItems = function sortItems2() {
      if (mutableState.sorted)
        return;
      var orderedNodes = menuRef.current.querySelectorAll(".szh-menu__item");
      items.sort(function(a, b) {
        return indexOfNode(orderedNodes, a) - indexOfNode(orderedNodes, b);
      });
      mutableState.sorted = true;
    };
    var index = -1, newItem = void 0;
    switch (actionType) {
      case HoverActionTypes.RESET:
        break;
      case HoverActionTypes.SET:
        newItem = item;
        break;
      case HoverActionTypes.UNSET:
        newItem = function newItem2(prevItem) {
          return prevItem === item ? void 0 : prevItem;
        };
        break;
      case HoverActionTypes.FIRST:
        sortItems();
        index = 0;
        newItem = items[index];
        break;
      case HoverActionTypes.LAST:
        sortItems();
        index = items.length - 1;
        newItem = items[index];
        break;
      case HoverActionTypes.SET_INDEX:
        sortItems();
        index = nextIndex;
        newItem = items[index];
        break;
      case HoverActionTypes.INCREASE:
        sortItems();
        index = hoverIndex;
        if (index < 0)
          index = items.indexOf(item);
        index++;
        if (index >= items.length)
          index = 0;
        newItem = items[index];
        break;
      case HoverActionTypes.DECREASE:
        sortItems();
        index = hoverIndex;
        if (index < 0)
          index = items.indexOf(item);
        index--;
        if (index < 0)
          index = items.length - 1;
        newItem = items[index];
        break;
      default:
        if (true)
          throw new Error("[React-Menu] Unknown hover action type: " + actionType);
    }
    if (!newItem)
      index = -1;
    setHoverItem(newItem);
    mutableState.hoverIndex = index;
  }, [menuRef, mutableState]);
  return {
    hoverItem,
    dispatch,
    updateItems
  };
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/getPositionHelpers.js
var getPositionHelpers = function getPositionHelpers2(containerRef, menuRef, menuScroll, boundingBoxPadding) {
  var menuRect = menuRef.current.getBoundingClientRect();
  var containerRect = containerRef.current.getBoundingClientRect();
  var boundingRect = menuScroll === window ? {
    left: 0,
    top: 0,
    right: document.documentElement.clientWidth,
    bottom: window.innerHeight
  } : menuScroll.getBoundingClientRect();
  var padding = parsePadding(boundingBoxPadding);
  var getLeftOverflow = function getLeftOverflow2(x) {
    return x + containerRect.left - boundingRect.left - padding.left;
  };
  var getRightOverflow = function getRightOverflow2(x) {
    return x + containerRect.left + menuRect.width - boundingRect.right + padding.right;
  };
  var getTopOverflow = function getTopOverflow2(y) {
    return y + containerRect.top - boundingRect.top - padding.top;
  };
  var getBottomOverflow = function getBottomOverflow2(y) {
    return y + containerRect.top + menuRect.height - boundingRect.bottom + padding.bottom;
  };
  var confineHorizontally = function confineHorizontally2(x) {
    var leftOverflow = getLeftOverflow(x);
    if (leftOverflow < 0) {
      x -= leftOverflow;
    } else {
      var rightOverflow = getRightOverflow(x);
      if (rightOverflow > 0) {
        x -= rightOverflow;
        leftOverflow = getLeftOverflow(x);
        if (leftOverflow < 0)
          x -= leftOverflow;
      }
    }
    return x;
  };
  var confineVertically = function confineVertically2(y) {
    var topOverflow = getTopOverflow(y);
    if (topOverflow < 0) {
      y -= topOverflow;
    } else {
      var bottomOverflow = getBottomOverflow(y);
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
        topOverflow = getTopOverflow(y);
        if (topOverflow < 0)
          y -= topOverflow;
      }
    }
    return y;
  };
  return {
    menuRect,
    containerRect,
    getLeftOverflow,
    getRightOverflow,
    getTopOverflow,
    getBottomOverflow,
    confineHorizontally,
    confineVertically
  };
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/positionContextMenu.js
var positionContextMenu = function positionContextMenu2(_ref) {
  var positionHelpers = _ref.positionHelpers, anchorPoint = _ref.anchorPoint;
  var menuRect = positionHelpers.menuRect, containerRect = positionHelpers.containerRect, getLeftOverflow = positionHelpers.getLeftOverflow, getRightOverflow = positionHelpers.getRightOverflow, getTopOverflow = positionHelpers.getTopOverflow, getBottomOverflow = positionHelpers.getBottomOverflow, confineHorizontally = positionHelpers.confineHorizontally, confineVertically = positionHelpers.confineVertically;
  var x, y;
  x = anchorPoint.x - containerRect.left;
  y = anchorPoint.y - containerRect.top;
  var rightOverflow = getRightOverflow(x);
  if (rightOverflow > 0) {
    var adjustedX = x - menuRect.width;
    var leftOverflow = getLeftOverflow(adjustedX);
    if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {
      x = adjustedX;
    }
    x = confineHorizontally(x);
  }
  var computedDirection = "bottom";
  var bottomOverflow = getBottomOverflow(y);
  if (bottomOverflow > 0) {
    var adjustedY = y - menuRect.height;
    var topOverflow = getTopOverflow(adjustedY);
    if (topOverflow >= 0 || -topOverflow < bottomOverflow) {
      y = adjustedY;
      computedDirection = "top";
    }
    y = confineVertically(y);
  }
  return {
    x,
    y,
    computedDirection
  };
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/placeArrowVertical.js
var placeArrowVertical = function placeArrowVertical2(_ref) {
  var arrowRef = _ref.arrowRef, menuY = _ref.menuY, anchorRect = _ref.anchorRect, containerRect = _ref.containerRect, menuRect = _ref.menuRect;
  var y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;
  var offset = arrowRef.current.offsetHeight * 1.25;
  y = Math.max(offset, y);
  y = Math.min(y, menuRect.height - offset);
  return y;
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/placeLeftorRight.js
var placeLeftorRight = function placeLeftorRight2(_ref) {
  var anchorRect = _ref.anchorRect, containerRect = _ref.containerRect, menuRect = _ref.menuRect, placeLeftorRightY = _ref.placeLeftorRightY, placeLeftX = _ref.placeLeftX, placeRightX = _ref.placeRightX, getLeftOverflow = _ref.getLeftOverflow, getRightOverflow = _ref.getRightOverflow, confineHorizontally = _ref.confineHorizontally, confineVertically = _ref.confineVertically, arrowRef = _ref.arrowRef, arrow = _ref.arrow, direction = _ref.direction, position = _ref.position;
  var computedDirection = direction;
  var y = placeLeftorRightY;
  if (position !== "initial") {
    y = confineVertically(y);
    if (position === "anchor") {
      y = Math.min(y, anchorRect.bottom - containerRect.top);
      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);
    }
  }
  var x, leftOverflow, rightOverflow;
  if (computedDirection === "left") {
    x = placeLeftX;
    if (position !== "initial") {
      leftOverflow = getLeftOverflow(x);
      if (leftOverflow < 0) {
        rightOverflow = getRightOverflow(placeRightX);
        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {
          x = placeRightX;
          computedDirection = "right";
        }
      }
    }
  } else {
    x = placeRightX;
    if (position !== "initial") {
      rightOverflow = getRightOverflow(x);
      if (rightOverflow > 0) {
        leftOverflow = getLeftOverflow(placeLeftX);
        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {
          x = placeLeftX;
          computedDirection = "left";
        }
      }
    }
  }
  if (position === "auto")
    x = confineHorizontally(x);
  var arrowY = arrow ? placeArrowVertical({
    menuY: y,
    arrowRef,
    anchorRect,
    containerRect,
    menuRect
  }) : void 0;
  return {
    arrowY,
    x,
    y,
    computedDirection
  };
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/placeArrowHorizontal.js
var placeArrowHorizontal = function placeArrowHorizontal2(_ref) {
  var arrowRef = _ref.arrowRef, menuX = _ref.menuX, anchorRect = _ref.anchorRect, containerRect = _ref.containerRect, menuRect = _ref.menuRect;
  var x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;
  var offset = arrowRef.current.offsetWidth * 1.25;
  x = Math.max(offset, x);
  x = Math.min(x, menuRect.width - offset);
  return x;
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/placeToporBottom.js
var placeToporBottom = function placeToporBottom2(_ref) {
  var anchorRect = _ref.anchorRect, containerRect = _ref.containerRect, menuRect = _ref.menuRect, placeToporBottomX = _ref.placeToporBottomX, placeTopY = _ref.placeTopY, placeBottomY = _ref.placeBottomY, getTopOverflow = _ref.getTopOverflow, getBottomOverflow = _ref.getBottomOverflow, confineHorizontally = _ref.confineHorizontally, confineVertically = _ref.confineVertically, arrowRef = _ref.arrowRef, arrow = _ref.arrow, direction = _ref.direction, position = _ref.position;
  var computedDirection = direction === "top" ? "top" : "bottom";
  var x = placeToporBottomX;
  if (position !== "initial") {
    x = confineHorizontally(x);
    if (position === "anchor") {
      x = Math.min(x, anchorRect.right - containerRect.left);
      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);
    }
  }
  var y, topOverflow, bottomOverflow;
  if (computedDirection === "top") {
    y = placeTopY;
    if (position !== "initial") {
      topOverflow = getTopOverflow(y);
      if (topOverflow < 0) {
        bottomOverflow = getBottomOverflow(placeBottomY);
        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {
          y = placeBottomY;
          computedDirection = "bottom";
        }
      }
    }
  } else {
    y = placeBottomY;
    if (position !== "initial") {
      bottomOverflow = getBottomOverflow(y);
      if (bottomOverflow > 0) {
        topOverflow = getTopOverflow(placeTopY);
        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {
          y = placeTopY;
          computedDirection = "top";
        }
      }
    }
  }
  if (position === "auto")
    y = confineVertically(y);
  var arrowX = arrow ? placeArrowHorizontal({
    menuX: x,
    arrowRef,
    anchorRect,
    containerRect,
    menuRect
  }) : void 0;
  return {
    arrowX,
    x,
    y,
    computedDirection
  };
};

// node_modules/@szhsin/react-menu/dist/es/positionUtils/positionMenu.js
var positionMenu = function positionMenu2(_ref) {
  var arrow = _ref.arrow, align = _ref.align, direction = _ref.direction, offsetX = _ref.offsetX, offsetY = _ref.offsetY, position = _ref.position, anchorRef = _ref.anchorRef, arrowRef = _ref.arrowRef, positionHelpers = _ref.positionHelpers;
  var menuRect = positionHelpers.menuRect, containerRect = positionHelpers.containerRect;
  var horizontalOffset = offsetX;
  var verticalOffset = offsetY;
  if (arrow) {
    if (direction === "left" || direction === "right") {
      horizontalOffset += arrowRef.current.offsetWidth;
    } else {
      verticalOffset += arrowRef.current.offsetHeight;
    }
  }
  var anchorRect = anchorRef.current.getBoundingClientRect();
  var placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;
  var placeRightX = anchorRect.right - containerRect.left + horizontalOffset;
  var placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;
  var placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;
  var placeToporBottomX, placeLeftorRightY;
  if (align === "end") {
    placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;
    placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;
  } else if (align === "center") {
    placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;
    placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;
  } else {
    placeToporBottomX = anchorRect.left - containerRect.left;
    placeLeftorRightY = anchorRect.top - containerRect.top;
  }
  placeToporBottomX += horizontalOffset;
  placeLeftorRightY += verticalOffset;
  var options = _extends({}, positionHelpers, {
    anchorRect,
    placeLeftX,
    placeRightX,
    placeLeftorRightY,
    placeTopY,
    placeBottomY,
    placeToporBottomX,
    arrowRef,
    arrow,
    direction,
    position
  });
  switch (direction) {
    case "left":
    case "right":
      return placeLeftorRight(options);
    case "top":
    case "bottom":
    default:
      return placeToporBottom(options);
  }
};

// node_modules/@szhsin/react-menu/dist/es/hooks/useIsomorphicLayoutEffect.js
var import_react5 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react5.useLayoutEffect : import_react5.useEffect;

// node_modules/@szhsin/react-menu/dist/es/hooks/useCombinedRef.js
var import_react6 = __toESM(require_react());
function setRef(ref, instance) {
  typeof ref === "function" ? ref(instance) : ref.current = instance;
}
var useCombinedRef = function useCombinedRef2(refA, refB) {
  return (0, import_react6.useMemo)(function() {
    if (!refA)
      return refB;
    if (!refB)
      return refA;
    return function(instance) {
      setRef(refA, instance);
      setRef(refB, instance);
    };
  }, [refA, refB]);
};

// node_modules/@szhsin/react-menu/dist/es/components/MenuList.js
var _excluded2 = ["ariaLabel", "menuClassName", "menuStyle", "arrowClassName", "arrowStyle", "anchorPoint", "anchorRef", "containerRef", "externalRef", "parentScrollingRef", "arrow", "align", "direction", "position", "overflow", "setDownOverflow", "repositionFlag", "captureFocus", "state", "endTransition", "isDisabled", "menuItemFocus", "offsetX", "offsetY", "children", "onClose"];
var MenuList = function MenuList2(_ref) {
  var ariaLabel = _ref.ariaLabel, menuClassName = _ref.menuClassName, menuStyle = _ref.menuStyle, arrowClassName = _ref.arrowClassName, arrowStyle = _ref.arrowStyle, anchorPoint = _ref.anchorPoint, anchorRef = _ref.anchorRef, containerRef = _ref.containerRef, externalRef = _ref.externalRef, parentScrollingRef = _ref.parentScrollingRef, arrow = _ref.arrow, _ref$align = _ref.align, align = _ref$align === void 0 ? "start" : _ref$align, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "bottom" : _ref$direction, _ref$position = _ref.position, position = _ref$position === void 0 ? "auto" : _ref$position, _ref$overflow = _ref.overflow, overflow = _ref$overflow === void 0 ? "visible" : _ref$overflow, setDownOverflow = _ref.setDownOverflow, repositionFlag = _ref.repositionFlag, _ref$captureFocus = _ref.captureFocus, captureFocus = _ref$captureFocus === void 0 ? true : _ref$captureFocus, state = _ref.state, endTransition = _ref.endTransition, isDisabled = _ref.isDisabled, menuItemFocus = _ref.menuItemFocus, _ref$offsetX = _ref.offsetX, offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX, _ref$offsetY = _ref.offsetY, offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY, children = _ref.children, onClose = _ref.onClose, restProps = _objectWithoutPropertiesLoose(_ref, _excluded2);
  var _useState = (0, import_react7.useState)({
    x: 0,
    y: 0
  }), menuPosition = _useState[0], setMenuPosition = _useState[1];
  var _useState2 = (0, import_react7.useState)({}), arrowPosition = _useState2[0], setArrowPosition = _useState2[1];
  var _useState3 = (0, import_react7.useState)(), overflowData = _useState3[0], setOverflowData = _useState3[1];
  var _useState4 = (0, import_react7.useState)(direction), expandedDirection = _useState4[0], setExpandedDirection = _useState4[1];
  var _useState5 = (0, import_react7.useState)(0), openSubmenuCount = _useState5[0], setOpenSubmenuCount = _useState5[1];
  var _useReducer = (0, import_react7.useReducer)(function(c) {
    return c + 1;
  }, 1), reposSubmenu = _useReducer[0], forceReposSubmenu = _useReducer[1];
  var _useContext = (0, import_react7.useContext)(SettingsContext), transition = _useContext.transition, boundingBoxRef = _useContext.boundingBoxRef, boundingBoxPadding = _useContext.boundingBoxPadding, rootMenuRef = _useContext.rootMenuRef, rootAnchorRef = _useContext.rootAnchorRef, scrollNodesRef = _useContext.scrollNodesRef, reposition = _useContext.reposition, viewScroll = _useContext.viewScroll;
  var reposFlag = (0, import_react7.useContext)(MenuListContext).reposSubmenu || repositionFlag;
  var menuRef = (0, import_react7.useRef)(null);
  var focusRef = (0, import_react7.useRef)();
  var arrowRef = (0, import_react7.useRef)();
  var prevOpen = (0, import_react7.useRef)(false);
  var latestMenuSize = (0, import_react7.useRef)({
    width: 0,
    height: 0
  });
  var latestHandlePosition = (0, import_react7.useRef)(function() {
  });
  var _useItems = useItems(menuRef, focusRef), hoverItem = _useItems.hoverItem, dispatch = _useItems.dispatch, updateItems = _useItems.updateItems;
  var isOpen = isMenuOpen(state);
  var openTransition = getTransition(transition, "open");
  var closeTransition = getTransition(transition, "close");
  var scrollNodes = scrollNodesRef.current;
  var onKeyDown = function onKeyDown2(e) {
    switch (e.key) {
      case Keys.HOME:
        dispatch(HoverActionTypes.FIRST);
        break;
      case Keys.END:
        dispatch(HoverActionTypes.LAST);
        break;
      case Keys.UP:
        dispatch(HoverActionTypes.DECREASE, hoverItem);
        break;
      case Keys.DOWN:
        dispatch(HoverActionTypes.INCREASE, hoverItem);
        break;
      case Keys.SPACE:
        if (e.target && e.target.className.indexOf(menuClass) !== -1) {
          e.preventDefault();
        }
        return;
      default:
        return;
    }
    e.preventDefault();
    e.stopPropagation();
  };
  var onAnimationEnd = function onAnimationEnd2() {
    if (state === "closing") {
      setOverflowData();
    }
    safeCall(endTransition);
  };
  var handlePosition = (0, import_react7.useCallback)(function(noOverflowCheck) {
    if (!containerRef.current) {
      if (true) {
        console.error('[React-Menu] Menu cannot be positioned properly as container ref is null. If you need to initialise `state` prop to "open" for ControlledMenu, please see this solution: https://codesandbox.io/s/initial-open-sp10wn');
      }
      return;
    }
    if (!scrollNodes.menu) {
      scrollNodes.menu = (boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current)) || window;
    }
    var positionHelpers = getPositionHelpers(containerRef, menuRef, scrollNodes.menu, boundingBoxPadding);
    var menuRect = positionHelpers.menuRect;
    var results = {
      computedDirection: "bottom"
    };
    if (anchorPoint) {
      results = positionContextMenu({
        positionHelpers,
        anchorPoint
      });
    } else if (anchorRef) {
      results = positionMenu({
        arrow,
        align,
        direction,
        offsetX,
        offsetY,
        position,
        anchorRef,
        arrowRef,
        positionHelpers
      });
    }
    var _results = results, arrowX = _results.arrowX, arrowY = _results.arrowY, x = _results.x, y = _results.y, computedDirection = _results.computedDirection;
    var menuHeight = menuRect.height;
    if (!noOverflowCheck && overflow !== "visible") {
      var getTopOverflow = positionHelpers.getTopOverflow, getBottomOverflow = positionHelpers.getBottomOverflow;
      var height, _overflowAmt;
      var prevHeight = latestMenuSize.current.height;
      var bottomOverflow = getBottomOverflow(y);
      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {
        height = menuHeight - bottomOverflow;
        _overflowAmt = bottomOverflow;
      } else {
        var topOverflow = getTopOverflow(y);
        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {
          height = menuHeight + topOverflow;
          _overflowAmt = 0 - topOverflow;
          if (height >= 0)
            y -= topOverflow;
        }
      }
      if (height >= 0) {
        menuHeight = height;
        setOverflowData({
          height,
          overflowAmt: _overflowAmt
        });
      } else {
        setOverflowData();
      }
    }
    if (arrow)
      setArrowPosition({
        x: arrowX,
        y: arrowY
      });
    setMenuPosition({
      x,
      y
    });
    setExpandedDirection(computedDirection);
    latestMenuSize.current = {
      width: menuRect.width,
      height: menuHeight
    };
  }, [arrow, align, boundingBoxPadding, direction, offsetX, offsetY, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollNodes]);
  useIsomorphicLayoutEffect(function() {
    if (isOpen) {
      handlePosition();
      if (prevOpen.current)
        forceReposSubmenu();
    }
    prevOpen.current = isOpen;
    latestHandlePosition.current = handlePosition;
  }, [isOpen, handlePosition, reposFlag]);
  useIsomorphicLayoutEffect(function() {
    if (overflowData && !setDownOverflow)
      menuRef.current.scrollTop = 0;
  }, [overflowData, setDownOverflow]);
  useIsomorphicLayoutEffect(function() {
    return updateItems;
  }, [updateItems]);
  (0, import_react7.useEffect)(function() {
    var menuScroll = scrollNodes.menu;
    if (!isOpen || !menuScroll)
      return;
    menuScroll = menuScroll.addEventListener ? menuScroll : window;
    if (!scrollNodes.anchors) {
      scrollNodes.anchors = [];
      var anchorScroll = getScrollAncestor(rootAnchorRef && rootAnchorRef.current);
      while (anchorScroll && anchorScroll !== menuScroll) {
        scrollNodes.anchors.push(anchorScroll);
        anchorScroll = getScrollAncestor(anchorScroll);
      }
    }
    var scroll = viewScroll;
    if (scrollNodes.anchors.length && scroll === "initial")
      scroll = "auto";
    if (scroll === "initial")
      return;
    var handleScroll = function handleScroll2() {
      if (scroll === "auto") {
        batchedUpdates(function() {
          return handlePosition(true);
        });
      } else {
        safeCall(onClose, {
          reason: CloseReason.SCROLL
        });
      }
    };
    var scrollObservers = scrollNodes.anchors.concat(viewScroll !== "initial" ? menuScroll : []);
    scrollObservers.forEach(function(o) {
      return o.addEventListener("scroll", handleScroll);
    });
    return function() {
      return scrollObservers.forEach(function(o) {
        return o.removeEventListener("scroll", handleScroll);
      });
    };
  }, [rootAnchorRef, scrollNodes, isOpen, onClose, viewScroll, handlePosition]);
  var hasOverflow = !!overflowData && overflowData.overflowAmt > 0;
  (0, import_react7.useEffect)(function() {
    if (hasOverflow || !isOpen || !parentScrollingRef)
      return;
    var handleScroll = function handleScroll2() {
      return batchedUpdates(handlePosition);
    };
    var parentScroll = parentScrollingRef.current;
    parentScroll.addEventListener("scroll", handleScroll);
    return function() {
      return parentScroll.removeEventListener("scroll", handleScroll);
    };
  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);
  (0, import_react7.useEffect)(function() {
    if (typeof ResizeObserver !== "function" || reposition === "initial")
      return;
    var resizeObserver = new ResizeObserver(function(_ref2) {
      var entry = _ref2[0];
      var borderBoxSize = entry.borderBoxSize, target = entry.target;
      var width, height;
      if (borderBoxSize) {
        var _ref3 = borderBoxSize[0] || borderBoxSize, inlineSize = _ref3.inlineSize, blockSize = _ref3.blockSize;
        width = inlineSize;
        height = blockSize;
      } else {
        var borderRect = target.getBoundingClientRect();
        width = borderRect.width;
        height = borderRect.height;
      }
      if (width === 0 || height === 0)
        return;
      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1))
        return;
      (0, import_react_dom2.flushSync)(function() {
        latestHandlePosition.current();
        forceReposSubmenu();
      });
    });
    var observeTarget = menuRef.current;
    resizeObserver.observe(observeTarget, {
      box: "border-box"
    });
    return function() {
      return resizeObserver.unobserve(observeTarget);
    };
  }, [reposition]);
  (0, import_react7.useEffect)(function() {
    if (!isOpen) {
      dispatch(HoverActionTypes.RESET);
      if (!closeTransition)
        setOverflowData();
      return;
    }
    var _ref4 = menuItemFocus || {}, position2 = _ref4.position, alwaysUpdate = _ref4.alwaysUpdate;
    var setItemFocus = function setItemFocus2() {
      if (position2 === FocusPositions.FIRST) {
        dispatch(HoverActionTypes.FIRST);
      } else if (position2 === FocusPositions.LAST) {
        dispatch(HoverActionTypes.LAST);
      } else if (position2 >= -1) {
        dispatch(HoverActionTypes.SET_INDEX, void 0, position2);
      }
    };
    if (alwaysUpdate) {
      setItemFocus();
    } else if (captureFocus) {
      var id = setTimeout(function() {
        if (!menuRef.current.contains(document.activeElement)) {
          focusRef.current.focus();
          setItemFocus();
        }
      }, openTransition ? 170 : 100);
      return function() {
        return clearTimeout(id);
      };
    }
  }, [isOpen, openTransition, closeTransition, captureFocus, menuItemFocus, dispatch]);
  var isSubmenuOpen = openSubmenuCount > 0;
  var itemContext = (0, import_react7.useMemo)(function() {
    return {
      isParentOpen: isOpen,
      isSubmenuOpen,
      setOpenSubmenuCount,
      dispatch,
      updateItems
    };
  }, [isOpen, isSubmenuOpen, dispatch, updateItems]);
  var maxHeight, overflowAmt;
  if (overflowData) {
    setDownOverflow ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;
  }
  var listContext = (0, import_react7.useMemo)(function() {
    return {
      reposSubmenu,
      overflow,
      overflowAmt,
      parentMenuRef: menuRef,
      parentDir: expandedDirection
    };
  }, [reposSubmenu, overflow, overflowAmt, expandedDirection]);
  var overflowStyle = maxHeight >= 0 ? {
    maxHeight,
    overflow
  } : void 0;
  var modifiers = (0, import_react7.useMemo)(function() {
    return {
      state,
      dir: expandedDirection
    };
  }, [state, expandedDirection]);
  var arrowModifiers = (0, import_react7.useMemo)(function() {
    return {
      dir: expandedDirection
    };
  }, [expandedDirection]);
  var _arrowClass = useBEM({
    block: menuClass,
    element: menuArrowClass,
    modifiers: arrowModifiers,
    className: arrowClassName
  });
  return (0, import_jsx_runtime2.jsxs)("ul", _extends({
    role: "menu",
    "aria-label": ariaLabel
  }, mergeProps({
    onKeyDown,
    onAnimationEnd
  }, restProps), commonProps(isDisabled), {
    ref: useCombinedRef(externalRef, menuRef),
    className: useBEM({
      block: menuClass,
      modifiers,
      className: menuClassName
    }),
    style: _extends({}, menuStyle, overflowStyle, {
      margin: 0,
      display: state === "closed" ? "none" : void 0,
      position: "absolute",
      left: menuPosition.x,
      top: menuPosition.y
    }),
    children: [(0, import_jsx_runtime2.jsx)("div", {
      ref: focusRef,
      tabIndex: -1,
      style: {
        position: "absolute",
        left: 0,
        top: 0
      }
    }), arrow && (0, import_jsx_runtime2.jsx)("div", {
      className: _arrowClass,
      style: _extends({}, arrowStyle, {
        position: "absolute",
        left: arrowPosition.x,
        top: arrowPosition.y
      }),
      ref: arrowRef
    }), (0, import_jsx_runtime2.jsx)(MenuListContext.Provider, {
      value: listContext,
      children: (0, import_jsx_runtime2.jsx)(MenuListItemContext.Provider, {
        value: itemContext,
        children: (0, import_jsx_runtime2.jsx)(HoverItemContext.Provider, {
          value: hoverItem,
          children
        })
      })
    })]
  }));
};

// node_modules/@szhsin/react-menu/dist/es/components/ControlledMenu.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _excluded3 = ["aria-label", "className", "containerProps", "initialMounted", "unmountOnClose", "transition", "transitionTimeout", "boundingBoxRef", "boundingBoxPadding", "reposition", "submenuOpenDelay", "submenuCloseDelay", "skipOpen", "viewScroll", "portal", "theming", "onItemClick", "onClose"];
var ControlledMenu = (0, import_react8.forwardRef)(function ControlledMenu2(_ref, externalRef) {
  var ariaLabel = _ref["aria-label"], className = _ref.className, containerProps = _ref.containerProps, initialMounted = _ref.initialMounted, unmountOnClose = _ref.unmountOnClose, transition = _ref.transition, transitionTimeout = _ref.transitionTimeout, boundingBoxRef = _ref.boundingBoxRef, boundingBoxPadding = _ref.boundingBoxPadding, _ref$reposition = _ref.reposition, reposition = _ref$reposition === void 0 ? "auto" : _ref$reposition, _ref$submenuOpenDelay = _ref.submenuOpenDelay, submenuOpenDelay = _ref$submenuOpenDelay === void 0 ? 300 : _ref$submenuOpenDelay, _ref$submenuCloseDela = _ref.submenuCloseDelay, submenuCloseDelay = _ref$submenuCloseDela === void 0 ? 150 : _ref$submenuCloseDela, skipOpen = _ref.skipOpen, _ref$viewScroll = _ref.viewScroll, viewScroll = _ref$viewScroll === void 0 ? "initial" : _ref$viewScroll, portal = _ref.portal, theming = _ref.theming, onItemClick = _ref.onItemClick, onClose = _ref.onClose, restProps = _objectWithoutPropertiesLoose(_ref, _excluded3);
  var containerRef = (0, import_react8.useRef)(null);
  var scrollNodesRef = (0, import_react8.useRef)({});
  var anchorRef = restProps.anchorRef, state = restProps.state;
  var settings = (0, import_react8.useMemo)(function() {
    return {
      initialMounted,
      unmountOnClose,
      transition,
      transitionTimeout,
      boundingBoxRef,
      boundingBoxPadding,
      rootMenuRef: containerRef,
      rootAnchorRef: anchorRef,
      scrollNodesRef,
      reposition,
      viewScroll
    };
  }, [initialMounted, unmountOnClose, transition, transitionTimeout, anchorRef, boundingBoxRef, boundingBoxPadding, reposition, viewScroll]);
  var itemSettings = (0, import_react8.useMemo)(function() {
    return {
      submenuOpenDelay,
      submenuCloseDelay
    };
  }, [submenuOpenDelay, submenuCloseDelay]);
  var eventHandlers = (0, import_react8.useMemo)(function() {
    return {
      handleClick: function handleClick(event, isCheckorRadio) {
        if (!event.stopPropagation)
          safeCall(onItemClick, event);
        var keepOpen = event.keepOpen;
        if (keepOpen === void 0) {
          keepOpen = isCheckorRadio && event.key === Keys.SPACE;
        }
        if (!keepOpen) {
          safeCall(onClose, {
            value: event.value,
            key: event.key,
            reason: CloseReason.CLICK
          });
        }
      },
      handleClose: function handleClose(key) {
        safeCall(onClose, {
          key,
          reason: CloseReason.CLICK
        });
      }
    };
  }, [onItemClick, onClose]);
  var onKeyDown = function onKeyDown2(_ref2) {
    var key = _ref2.key;
    switch (key) {
      case Keys.ESC:
        safeCall(onClose, {
          key,
          reason: CloseReason.CANCEL
        });
        break;
    }
  };
  var onBlur = function onBlur2(e) {
    if (isMenuOpen(state) && !e.currentTarget.contains(e.relatedTarget || document.activeElement)) {
      safeCall(onClose, {
        reason: CloseReason.BLUR
      });
      if (skipOpen) {
        skipOpen.current = true;
        setTimeout(function() {
          return skipOpen.current = false;
        }, 300);
      }
    }
  };
  var itemTransition = getTransition(transition, "item");
  var modifiers = (0, import_react8.useMemo)(function() {
    return {
      theme: theming,
      itemTransition
    };
  }, [theming, itemTransition]);
  var menuList = (0, import_jsx_runtime3.jsx)("div", _extends({}, mergeProps({
    onKeyDown,
    onBlur
  }, containerProps), {
    className: useBEM({
      block: menuContainerClass,
      modifiers,
      className
    }),
    style: _extends({}, containerProps == null ? void 0 : containerProps.style, {
      position: "relative"
    }),
    ref: containerRef,
    children: state && (0, import_jsx_runtime3.jsx)(SettingsContext.Provider, {
      value: settings,
      children: (0, import_jsx_runtime3.jsx)(ItemSettingsContext.Provider, {
        value: itemSettings,
        children: (0, import_jsx_runtime3.jsx)(EventHandlersContext.Provider, {
          value: eventHandlers,
          children: (0, import_jsx_runtime3.jsx)(MenuList, _extends({}, restProps, {
            ariaLabel: ariaLabel || "Menu",
            externalRef,
            containerRef,
            onClose
          }))
        })
      })
    })
  }));
  if (portal === true && typeof document !== "undefined") {
    return (0, import_react_dom3.createPortal)(menuList, document.body);
  } else if (portal) {
    return portal.target ? (0, import_react_dom3.createPortal)(menuList, portal.target) : portal.stablePosition ? null : menuList;
  }
  return menuList;
});
true ? ControlledMenu.propTypes = _extends({}, rootMenuPropTypes, {
  state: (0, import_prop_types3.oneOf)(values(MenuStateMap)),
  anchorPoint: (0, import_prop_types3.exact)({
    x: import_prop_types3.number,
    y: import_prop_types3.number
  }),
  anchorRef: import_prop_types3.object,
  skipOpen: import_prop_types3.object,
  captureFocus: import_prop_types3.bool,
  menuItemFocus: (0, import_prop_types3.exact)({
    position: (0, import_prop_types3.oneOfType)([import_prop_types3.string, import_prop_types3.number]),
    alwaysUpdate: import_prop_types3.bool
  }),
  onClose: import_prop_types3.func
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/Menu.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@szhsin/react-menu/dist/es/hooks/useMenuStateAndFocus.js
var import_react10 = __toESM(require_react());

// node_modules/react-transition-state/dist/index.es.js
var import_react9 = __toESM(require_react());
var PRE_ENTER = 0;
var ENTERING = 1;
var ENTERED = 2;
var PRE_EXIT = 3;
var EXITING = 4;
var EXITED = 5;
var UNMOUNTED = 6;
var STATES = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"];
var startOrEnd = function startOrEnd2(unmounted) {
  return unmounted ? UNMOUNTED : EXITED;
};
var updateState = function updateState2(state, setState, latestState, timeoutId, onChange) {
  clearTimeout(timeoutId.current);
  setState(state);
  latestState.current = state;
  onChange && onChange({
    state: STATES[state]
  });
};
var useTransition = function useTransition2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$enter = _ref.enter, enter = _ref$enter === void 0 ? true : _ref$enter, _ref$exit = _ref.exit, exit = _ref$exit === void 0 ? true : _ref$exit, preEnter = _ref.preEnter, preExit = _ref.preExit, timeout = _ref.timeout, initialEntered = _ref.initialEntered, mountOnEnter = _ref.mountOnEnter, unmountOnExit = _ref.unmountOnExit, onChange = _ref.onChange;
  var _useState = (0, import_react9.useState)(initialEntered ? ENTERED : startOrEnd(mountOnEnter)), state = _useState[0], setState = _useState[1];
  var latestState = (0, import_react9.useRef)(state);
  var timeoutId = (0, import_react9.useRef)();
  var enterTimeout, exitTimeout;
  if (typeof timeout === "object") {
    enterTimeout = timeout.enter;
    exitTimeout = timeout.exit;
  } else {
    enterTimeout = exitTimeout = timeout;
  }
  var endTransition = (0, import_react9.useCallback)(function() {
    var newState;
    switch (latestState.current) {
      case ENTERING:
      case PRE_ENTER:
        newState = ENTERED;
        break;
      case EXITING:
      case PRE_EXIT:
        newState = startOrEnd(unmountOnExit);
        break;
    }
    if (newState !== void 0) {
      updateState(newState, setState, latestState, timeoutId, onChange);
    }
  }, [onChange, unmountOnExit]);
  var toggle = (0, import_react9.useCallback)(function(toEnter) {
    var transitState = function transitState2(newState) {
      updateState(newState, setState, latestState, timeoutId, onChange);
      switch (newState) {
        case ENTERING:
          if (enterTimeout >= 0)
            timeoutId.current = setTimeout(endTransition, enterTimeout);
          break;
        case EXITING:
          if (exitTimeout >= 0)
            timeoutId.current = setTimeout(endTransition, exitTimeout);
          break;
        case PRE_ENTER:
        case PRE_EXIT:
          timeoutId.current = setTimeout(function() {
            return transitState2(newState + 1);
          }, 0);
          break;
      }
    };
    var enterStage = latestState.current <= ENTERED;
    if (typeof toEnter !== "boolean")
      toEnter = !enterStage;
    if (toEnter) {
      if (!enterStage) {
        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);
      }
    } else {
      if (enterStage) {
        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));
      }
    }
  }, [endTransition, onChange, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);
  (0, import_react9.useEffect)(function() {
    return function() {
      return clearTimeout(timeoutId.current);
    };
  }, []);
  return [STATES[state], toggle, endTransition];
};

// node_modules/@szhsin/react-menu/dist/es/hooks/useMenuState.js
var useMenuState = function useMenuState2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, initialMounted = _ref.initialMounted, unmountOnClose = _ref.unmountOnClose, transition = _ref.transition, _ref$transitionTimeou = _ref.transitionTimeout, transitionTimeout = _ref$transitionTimeou === void 0 ? 500 : _ref$transitionTimeou;
  var _useTransition = useTransition({
    mountOnEnter: !initialMounted,
    unmountOnExit: unmountOnClose,
    timeout: transitionTimeout,
    enter: getTransition(transition, "open"),
    exit: getTransition(transition, "close")
  }), state = _useTransition[0], toggleMenu = _useTransition[1], endTransition = _useTransition[2];
  return [{
    state: MenuStateMap[state],
    endTransition
  }, toggleMenu];
};

// node_modules/@szhsin/react-menu/dist/es/hooks/useMenuStateAndFocus.js
var useMenuStateAndFocus = function useMenuStateAndFocus2(options) {
  var _useMenuState = useMenuState(options), menuProps = _useMenuState[0], toggleMenu = _useMenuState[1];
  var _useState = (0, import_react10.useState)(), menuItemFocus = _useState[0], setMenuItemFocus = _useState[1];
  var openMenu = function openMenu2(position, alwaysUpdate) {
    setMenuItemFocus({
      position,
      alwaysUpdate
    });
    toggleMenu(true);
  };
  return [_extends({
    menuItemFocus
  }, menuProps), toggleMenu, openMenu];
};

// node_modules/@szhsin/react-menu/dist/es/hooks/useMenuChange.js
var import_react11 = __toESM(require_react());
var useMenuChange = function useMenuChange2(onMenuChange, isOpen) {
  var prevOpen = (0, import_react11.useRef)(isOpen);
  (0, import_react11.useEffect)(function() {
    if (prevOpen.current !== isOpen)
      safeCall(onMenuChange, {
        open: isOpen
      });
    prevOpen.current = isOpen;
  }, [onMenuChange, isOpen]);
};

// node_modules/@szhsin/react-menu/dist/es/components/Menu.js
var _excluded4 = ["aria-label", "captureFocus", "menuButton", "instanceRef", "onMenuChange"];
var Menu = (0, import_react12.forwardRef)(function Menu2(_ref, externalRef) {
  var ariaLabel = _ref["aria-label"], menuButton = _ref.menuButton, instanceRef = _ref.instanceRef, onMenuChange = _ref.onMenuChange, restProps = _objectWithoutPropertiesLoose(_ref, _excluded4);
  var _useMenuStateAndFocus = useMenuStateAndFocus(restProps), stateProps = _useMenuStateAndFocus[0], toggleMenu = _useMenuStateAndFocus[1], openMenu = _useMenuStateAndFocus[2];
  var isOpen = isMenuOpen(stateProps.state);
  var skipOpen = (0, import_react12.useRef)(false);
  var buttonRef = (0, import_react12.useRef)(null);
  var handleClose = (0, import_react12.useCallback)(function(e) {
    toggleMenu(false);
    if (e.key)
      buttonRef.current.focus();
  }, [toggleMenu]);
  var onClick = function onClick2(e) {
    if (skipOpen.current)
      return;
    openMenu(e.detail === 0 ? FocusPositions.FIRST : void 0);
  };
  var onKeyDown = function onKeyDown2(e) {
    switch (e.key) {
      case Keys.UP:
        openMenu(FocusPositions.LAST);
        break;
      case Keys.DOWN:
        openMenu(FocusPositions.FIRST);
        break;
      default:
        return;
    }
    e.preventDefault();
  };
  var button = safeCall(menuButton, {
    open: isOpen
  });
  if (!button || !button.type)
    throw new Error("Menu requires a menuButton prop.");
  var buttonProps = _extends({
    ref: useCombinedRef(button.ref, buttonRef)
  }, mergeProps({
    onClick,
    onKeyDown
  }, button.props));
  if (getName(button.type) === "MenuButton") {
    buttonProps.isOpen = isOpen;
  }
  var renderButton = (0, import_react12.cloneElement)(button, buttonProps);
  useMenuChange(onMenuChange, isOpen);
  (0, import_react12.useImperativeHandle)(instanceRef, function() {
    return {
      openMenu,
      closeMenu: function closeMenu() {
        return toggleMenu(false);
      }
    };
  });
  return (0, import_jsx_runtime4.jsxs)(import_react12.Fragment, {
    children: [renderButton, (0, import_jsx_runtime4.jsx)(ControlledMenu, _extends({}, restProps, stateProps, {
      "aria-label": ariaLabel || (typeof button.props.children === "string" ? button.props.children : "Menu"),
      anchorRef: buttonRef,
      ref: externalRef,
      onClose: handleClose,
      skipOpen
    }))]
  });
});
true ? Menu.propTypes = _extends({}, rootMenuPropTypes, uncontrolledMenuPropTypes, {
  menuButton: (0, import_prop_types4.oneOfType)([import_prop_types4.element, import_prop_types4.func]).isRequired
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/SubMenu.js
var import_react14 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
var import_prop_types5 = __toESM(require_prop_types());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());

// node_modules/@szhsin/react-menu/dist/es/utils/withHovering.js
var import_react13 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var withHovering = function withHovering2(name, WrappedComponent) {
  var Component = (0, import_react13.memo)(WrappedComponent);
  var WithHovering = (0, import_react13.forwardRef)(function(props, ref) {
    var itemRef = (0, import_react13.useRef)(null);
    return (0, import_jsx_runtime5.jsx)(Component, _extends({}, props, {
      itemRef,
      externalRef: ref,
      isHovering: (0, import_react13.useContext)(HoverItemContext) === itemRef.current
    }));
  });
  WithHovering.displayName = "WithHovering(" + name + ")";
  return WithHovering;
};

// node_modules/@szhsin/react-menu/dist/es/hooks/useItemEffect.js
var useItemEffect = function useItemEffect2(isDisabled, itemRef, updateItems) {
  useIsomorphicLayoutEffect(function() {
    if (!updateItems) {
      throw new Error("[React-Menu] This menu item or submenu should be rendered under a menu: " + itemRef.current.outerHTML);
    }
    if (isDisabled)
      return;
    var item = itemRef.current;
    updateItems(item, true);
    return function() {
      updateItems(item);
    };
  }, [isDisabled, itemRef, updateItems]);
};

// node_modules/@szhsin/react-menu/dist/es/components/SubMenu.js
var _excluded5 = ["aria-label", "className", "disabled", "direction", "label", "openTrigger", "onMenuChange", "isHovering", "instanceRef", "itemRef", "captureFocus", "repositionFlag", "itemProps"];
var _excluded22 = ["ref", "className"];
var SubMenu = withHovering("SubMenu", function SubMenu2(_ref) {
  var ariaLabel = _ref["aria-label"], className = _ref.className, disabled = _ref.disabled, direction = _ref.direction, label = _ref.label, openTrigger = _ref.openTrigger, onMenuChange = _ref.onMenuChange, isHovering = _ref.isHovering, instanceRef = _ref.instanceRef, itemRef = _ref.itemRef, _ref$itemProps = _ref.itemProps, itemProps = _ref$itemProps === void 0 ? {} : _ref$itemProps, restProps = _objectWithoutPropertiesLoose(_ref, _excluded5);
  var settings = (0, import_react14.useContext)(SettingsContext);
  var rootMenuRef = settings.rootMenuRef;
  var _useContext = (0, import_react14.useContext)(ItemSettingsContext), submenuOpenDelay = _useContext.submenuOpenDelay, submenuCloseDelay = _useContext.submenuCloseDelay;
  var _useContext2 = (0, import_react14.useContext)(MenuListContext), parentMenuRef = _useContext2.parentMenuRef, parentDir = _useContext2.parentDir, parentOverflow = _useContext2.overflow;
  var _useContext3 = (0, import_react14.useContext)(MenuListItemContext), isParentOpen = _useContext3.isParentOpen, isSubmenuOpen = _useContext3.isSubmenuOpen, setOpenSubmenuCount = _useContext3.setOpenSubmenuCount, dispatch = _useContext3.dispatch, updateItems = _useContext3.updateItems;
  var isPortal = parentOverflow !== "visible";
  var _useMenuStateAndFocus = useMenuStateAndFocus(settings), stateProps = _useMenuStateAndFocus[0], toggleMenu = _useMenuStateAndFocus[1], _openMenu = _useMenuStateAndFocus[2];
  var state = stateProps.state;
  var isDisabled = !!disabled;
  var isOpen = isMenuOpen(state);
  var containerRef = (0, import_react14.useRef)(null);
  var timeoutId = (0, import_react14.useRef)(0);
  var stopTimer = function stopTimer2() {
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
      timeoutId.current = 0;
    }
  };
  var _openMenu2 = function openMenu() {
    stopTimer();
    setHover();
    !isDisabled && _openMenu.apply(void 0, arguments);
  };
  var setHover = function setHover2() {
    return !isHovering && !isDisabled && dispatch(HoverActionTypes.SET, itemRef.current);
  };
  var delayOpen = function delayOpen2(delay) {
    setHover();
    if (!openTrigger)
      timeoutId.current = setTimeout(function() {
        return batchedUpdates(_openMenu2);
      }, Math.max(delay, 0));
  };
  var handlePointerMove = function handlePointerMove2() {
    if (timeoutId.current || isOpen || isDisabled)
      return;
    if (isSubmenuOpen) {
      timeoutId.current = setTimeout(function() {
        return delayOpen(submenuOpenDelay - submenuCloseDelay);
      }, submenuCloseDelay);
    } else {
      delayOpen(submenuOpenDelay);
    }
  };
  var handlePointerLeave = function handlePointerLeave2() {
    stopTimer();
    if (!isOpen)
      dispatch(HoverActionTypes.UNSET, itemRef.current);
  };
  var handleKeyDown = function handleKeyDown2(e) {
    var handled = false;
    switch (e.key) {
      case Keys.LEFT:
        if (isOpen) {
          itemRef.current.focus();
          toggleMenu(false);
          handled = true;
        }
        break;
      case Keys.RIGHT:
        if (!isOpen)
          handled = true;
        break;
    }
    if (handled) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
  var handleItemKeyDown = function handleItemKeyDown2(e) {
    if (!isHovering)
      return;
    switch (e.key) {
      case Keys.ENTER:
      case Keys.SPACE:
      case Keys.RIGHT:
        openTrigger !== "none" && _openMenu2(FocusPositions.FIRST);
        break;
    }
  };
  useItemEffect(isDisabled, itemRef, updateItems);
  useMenuChange(onMenuChange, isOpen);
  (0, import_react14.useEffect)(function() {
    return function() {
      return clearTimeout(timeoutId.current);
    };
  }, []);
  (0, import_react14.useEffect)(function() {
    if (isHovering && isParentOpen) {
      itemRef.current.focus();
    } else {
      toggleMenu(false);
    }
  }, [isHovering, isParentOpen, toggleMenu, itemRef]);
  (0, import_react14.useEffect)(function() {
    setOpenSubmenuCount(function(count) {
      return isOpen ? count + 1 : Math.max(count - 1, 0);
    });
  }, [setOpenSubmenuCount, isOpen]);
  (0, import_react14.useImperativeHandle)(instanceRef, function() {
    return {
      openMenu: function openMenu() {
        isParentOpen && _openMenu2.apply(void 0, arguments);
      },
      closeMenu: function closeMenu() {
        if (isOpen) {
          itemRef.current.focus();
          toggleMenu(false);
        }
      }
    };
  });
  var modifiers = (0, import_react14.useMemo)(function() {
    return {
      open: isOpen,
      hover: isHovering,
      disabled: isDisabled,
      submenu: true
    };
  }, [isOpen, isHovering, isDisabled]);
  var externalItemRef = itemProps.ref, itemClassName = itemProps.className, restItemProps = _objectWithoutPropertiesLoose(itemProps, _excluded22);
  var mergedItemProps = mergeProps({
    onPointerMove: handlePointerMove,
    onPointerLeave: handlePointerLeave,
    onKeyDown: handleItemKeyDown,
    onClick: function onClick() {
      return openTrigger !== "none" && _openMenu2();
    }
  }, restItemProps);
  var getMenuList = function getMenuList2() {
    var menuList = (0, import_jsx_runtime6.jsx)(MenuList, _extends({}, restProps, stateProps, {
      ariaLabel: ariaLabel || (typeof label === "string" ? label : "Submenu"),
      anchorRef: itemRef,
      containerRef: isPortal ? rootMenuRef : containerRef,
      direction: direction || (parentDir === "right" || parentDir === "left" ? parentDir : "right"),
      parentScrollingRef: isPortal && parentMenuRef,
      isDisabled
    }));
    var container = rootMenuRef.current;
    return isPortal && container ? (0, import_react_dom4.createPortal)(menuList, container) : menuList;
  };
  return (0, import_jsx_runtime6.jsxs)("li", {
    className: useBEM({
      block: menuClass,
      element: subMenuClass,
      className
    }),
    style: {
      position: "relative"
    },
    role: "presentation",
    ref: containerRef,
    onKeyDown: handleKeyDown,
    children: [(0, import_jsx_runtime6.jsx)("div", _extends({
      role: "menuitem",
      "aria-haspopup": true,
      "aria-expanded": isOpen
    }, mergedItemProps, commonProps(isDisabled, isHovering), {
      ref: useCombinedRef(externalItemRef, itemRef),
      className: useBEM({
        block: menuClass,
        element: menuItemClass,
        modifiers,
        className: itemClassName
      }),
      children: (0, import_react14.useMemo)(function() {
        return safeCall(label, modifiers);
      }, [label, modifiers])
    })), state && getMenuList()]
  });
});
true ? SubMenu.propTypes = _extends({}, menuPropTypes, uncontrolledMenuPropTypes, {
  disabled: import_prop_types5.bool,
  openTrigger: (0, import_prop_types5.oneOf)(["none", "clickOnly"]),
  label: (0, import_prop_types5.oneOfType)([import_prop_types5.node, import_prop_types5.func]),
  itemProps: (0, import_prop_types5.shape)(_extends({}, stylePropTypes()))
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/MenuItem.js
var import_react16 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());

// node_modules/@szhsin/react-menu/dist/es/hooks/useItemState.js
var import_react15 = __toESM(require_react());
var useItemState = function useItemState2(itemRef, focusRef, isHovering, isDisabled) {
  var _useContext = (0, import_react15.useContext)(ItemSettingsContext), submenuCloseDelay = _useContext.submenuCloseDelay;
  var _useContext2 = (0, import_react15.useContext)(MenuListItemContext), isParentOpen = _useContext2.isParentOpen, isSubmenuOpen = _useContext2.isSubmenuOpen, dispatch = _useContext2.dispatch, updateItems = _useContext2.updateItems;
  var timeoutId = (0, import_react15.useRef)(0);
  var setHover = function setHover2() {
    !isHovering && !isDisabled && dispatch(HoverActionTypes.SET, itemRef.current);
  };
  var unsetHover = function unsetHover2() {
    !isDisabled && dispatch(HoverActionTypes.UNSET, itemRef.current);
  };
  var onBlur = function onBlur2(e) {
    if (isHovering && !e.currentTarget.contains(e.relatedTarget))
      unsetHover();
  };
  var onPointerMove = function onPointerMove2() {
    if (isSubmenuOpen) {
      if (!timeoutId.current)
        timeoutId.current = setTimeout(function() {
          timeoutId.current = 0;
          setHover();
        }, submenuCloseDelay);
    } else {
      setHover();
    }
  };
  var onPointerLeave = function onPointerLeave2(_, keepHover) {
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
      timeoutId.current = 0;
    }
    !keepHover && unsetHover();
  };
  useItemEffect(isDisabled, itemRef, updateItems);
  (0, import_react15.useEffect)(function() {
    return function() {
      return clearTimeout(timeoutId.current);
    };
  }, []);
  (0, import_react15.useEffect)(function() {
    if (isHovering && isParentOpen) {
      focusRef.current && focusRef.current.focus();
    }
  }, [focusRef, isHovering, isParentOpen]);
  return {
    setHover,
    onBlur,
    onPointerMove,
    onPointerLeave
  };
};

// node_modules/@szhsin/react-menu/dist/es/components/MenuItem.js
var _excluded6 = ["className", "value", "href", "type", "checked", "disabled", "children", "onClick", "isHovering", "itemRef", "externalRef"];
var _excluded23 = ["setHover"];
var MenuItem = withHovering("MenuItem", function MenuItem2(_ref) {
  var className = _ref.className, value = _ref.value, href = _ref.href, type = _ref.type, checked = _ref.checked, disabled = _ref.disabled, children = _ref.children, onClick = _ref.onClick, isHovering = _ref.isHovering, itemRef = _ref.itemRef, externalRef = _ref.externalRef, restProps = _objectWithoutPropertiesLoose(_ref, _excluded6);
  var isDisabled = !!disabled;
  var _useItemState = useItemState(itemRef, itemRef, isHovering, isDisabled), setHover = _useItemState.setHover, restStateProps = _objectWithoutPropertiesLoose(_useItemState, _excluded23);
  var eventHandlers = (0, import_react16.useContext)(EventHandlersContext);
  var radioGroup = (0, import_react16.useContext)(RadioGroupContext);
  var isRadio = type === "radio";
  var isCheckBox = type === "checkbox";
  var isAnchor = !!href && !isDisabled && !isRadio && !isCheckBox;
  var isChecked = isRadio ? radioGroup.value === value : isCheckBox ? !!checked : false;
  var handleClick = function handleClick2(e) {
    if (isDisabled) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    var event = {
      value,
      syntheticEvent: e
    };
    if (e.key !== void 0)
      event.key = e.key;
    if (isCheckBox)
      event.checked = !isChecked;
    if (isRadio)
      event.name = radioGroup.name;
    safeCall(onClick, event);
    if (isRadio)
      safeCall(radioGroup.onRadioChange, event);
    eventHandlers.handleClick(event, isCheckBox || isRadio);
  };
  var handleKeyDown = function handleKeyDown2(e) {
    if (!isHovering)
      return;
    switch (e.key) {
      case Keys.ENTER:
      case Keys.SPACE:
        if (isAnchor) {
          itemRef.current.click();
        } else {
          handleClick(e);
        }
        break;
    }
  };
  var modifiers = (0, import_react16.useMemo)(function() {
    return {
      type,
      disabled: isDisabled,
      hover: isHovering,
      checked: isChecked,
      anchor: isAnchor
    };
  }, [type, isDisabled, isHovering, isChecked, isAnchor]);
  var mergedProps = mergeProps(_extends({}, restStateProps, {
    onPointerDown: setHover,
    onKeyDown: handleKeyDown,
    onClick: handleClick
  }), restProps);
  var menuItemProps = _extends({
    role: isRadio ? "menuitemradio" : isCheckBox ? "menuitemcheckbox" : "menuitem",
    "aria-checked": isRadio || isCheckBox ? isChecked : void 0
  }, mergedProps, commonProps(isDisabled, isHovering), {
    ref: useCombinedRef(externalRef, itemRef),
    className: useBEM({
      block: menuClass,
      element: menuItemClass,
      modifiers,
      className
    }),
    children: (0, import_react16.useMemo)(function() {
      return safeCall(children, modifiers);
    }, [children, modifiers])
  });
  if (isAnchor) {
    return (0, import_jsx_runtime7.jsx)("li", {
      role: "presentation",
      children: (0, import_jsx_runtime7.jsx)("a", _extends({
        href
      }, menuItemProps))
    });
  } else {
    return (0, import_jsx_runtime7.jsx)("li", _extends({}, menuItemProps));
  }
});
true ? MenuItem.propTypes = _extends({}, stylePropTypes(), {
  value: import_prop_types6.any,
  href: import_prop_types6.string,
  type: (0, import_prop_types6.oneOf)(["checkbox", "radio"]),
  checked: import_prop_types6.bool,
  disabled: import_prop_types6.bool,
  children: (0, import_prop_types6.oneOfType)([import_prop_types6.node, import_prop_types6.func]),
  onClick: import_prop_types6.func
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/FocusableItem.js
var import_react17 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded7 = ["className", "disabled", "children", "isHovering", "itemRef", "externalRef"];
var _excluded24 = ["setHover", "onPointerLeave"];
var FocusableItem = withHovering("FocusableItem", function FocusableItem2(_ref) {
  var className = _ref.className, disabled = _ref.disabled, children = _ref.children, isHovering = _ref.isHovering, itemRef = _ref.itemRef, externalRef = _ref.externalRef, restProps = _objectWithoutPropertiesLoose(_ref, _excluded7);
  var isDisabled = !!disabled;
  var ref = (0, import_react17.useRef)(null);
  var _useItemState = useItemState(itemRef, ref, isHovering, isDisabled), setHover = _useItemState.setHover, _onPointerLeave = _useItemState.onPointerLeave, restStateProps = _objectWithoutPropertiesLoose(_useItemState, _excluded24);
  var _useContext = (0, import_react17.useContext)(EventHandlersContext), handleClose = _useContext.handleClose;
  var modifiers = (0, import_react17.useMemo)(function() {
    return {
      disabled: isDisabled,
      hover: isHovering,
      focusable: true
    };
  }, [isDisabled, isHovering]);
  var renderChildren = (0, import_react17.useMemo)(function() {
    return safeCall(children, _extends({}, modifiers, {
      ref,
      closeMenu: handleClose
    }));
  }, [children, modifiers, handleClose]);
  var mergedProps = mergeProps(_extends({}, restStateProps, {
    onPointerLeave: function onPointerLeave(e) {
      return _onPointerLeave(e, true);
    },
    onFocus: setHover
  }), restProps);
  return (0, import_jsx_runtime8.jsx)("li", _extends({
    role: "menuitem"
  }, mergedProps, commonProps(isDisabled), {
    ref: useCombinedRef(externalRef, itemRef),
    className: useBEM({
      block: menuClass,
      element: menuItemClass,
      modifiers,
      className
    }),
    children: renderChildren
  }));
});
true ? FocusableItem.propTypes = _extends({}, stylePropTypes(), {
  disabled: import_prop_types7.bool,
  children: import_prop_types7.func
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/MenuDivider.js
var import_react18 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var _excluded8 = ["className"];
var MenuDivider = (0, import_react18.memo)((0, import_react18.forwardRef)(function MenuDivider2(_ref, externalRef) {
  var className = _ref.className, restProps = _objectWithoutPropertiesLoose(_ref, _excluded8);
  return (0, import_jsx_runtime9.jsx)("li", _extends({
    role: "separator"
  }, restProps, {
    ref: externalRef,
    className: useBEM({
      block: menuClass,
      element: menuDividerClass,
      className
    })
  }));
}));
true ? MenuDivider.propTypes = _extends({}, stylePropTypes()) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/MenuHeader.js
var import_react19 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded9 = ["className"];
var MenuHeader = (0, import_react19.memo)((0, import_react19.forwardRef)(function MenuHeader2(_ref, externalRef) {
  var className = _ref.className, restProps = _objectWithoutPropertiesLoose(_ref, _excluded9);
  return (0, import_jsx_runtime10.jsx)("li", _extends({
    role: "presentation"
  }, restProps, {
    ref: externalRef,
    className: useBEM({
      block: menuClass,
      element: menuHeaderClass,
      className
    })
  }));
}));
true ? MenuHeader.propTypes = _extends({}, stylePropTypes()) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/MenuGroup.js
var import_react20 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded10 = ["className", "style", "takeOverflow"];
var MenuGroup = (0, import_react20.forwardRef)(function MenuGroup2(_ref, externalRef) {
  var className = _ref.className, style = _ref.style, takeOverflow = _ref.takeOverflow, restProps = _objectWithoutPropertiesLoose(_ref, _excluded10);
  var ref = (0, import_react20.useRef)(null);
  var _useState = (0, import_react20.useState)(), overflowStyle = _useState[0], setOverflowStyle = _useState[1];
  var _useContext = (0, import_react20.useContext)(MenuListContext), overflow = _useContext.overflow, overflowAmt = _useContext.overflowAmt;
  useIsomorphicLayoutEffect(function() {
    var maxHeight;
    if (takeOverflow && overflowAmt >= 0) {
      maxHeight = ref.current.getBoundingClientRect().height - overflowAmt;
      if (maxHeight < 0)
        maxHeight = 0;
    }
    setOverflowStyle(maxHeight >= 0 ? {
      maxHeight,
      overflow
    } : void 0);
  }, [takeOverflow, overflow, overflowAmt]);
  useIsomorphicLayoutEffect(function() {
    if (overflowStyle)
      ref.current.scrollTop = 0;
  }, [overflowStyle]);
  return (0, import_jsx_runtime11.jsx)("div", _extends({}, restProps, {
    ref: useCombinedRef(externalRef, ref),
    className: useBEM({
      block: menuClass,
      element: menuGroupClass,
      className
    }),
    style: _extends({}, style, overflowStyle)
  }));
});
true ? MenuGroup.propTypes = _extends({}, stylePropTypes(), {
  takeOverflow: import_prop_types8.bool
}) : void 0;

// node_modules/@szhsin/react-menu/dist/es/components/MenuRadioGroup.js
var import_react21 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded11 = ["aria-label", "className", "name", "value", "onRadioChange"];
var MenuRadioGroup = (0, import_react21.forwardRef)(function MenuRadioGroup2(_ref, externalRef) {
  var ariaLabel = _ref["aria-label"], className = _ref.className, name = _ref.name, value = _ref.value, onRadioChange = _ref.onRadioChange, restProps = _objectWithoutPropertiesLoose(_ref, _excluded11);
  var contextValue = (0, import_react21.useMemo)(function() {
    return {
      name,
      value,
      onRadioChange
    };
  }, [name, value, onRadioChange]);
  return (0, import_jsx_runtime12.jsx)(RadioGroupContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime12.jsx)("li", {
      role: "presentation",
      children: (0, import_jsx_runtime12.jsx)("ul", _extends({
        role: "group",
        "aria-label": ariaLabel || name || "Radio group"
      }, restProps, {
        ref: externalRef,
        className: useBEM({
          block: menuClass,
          element: radioGroupClass,
          className
        })
      }))
    })
  });
});
true ? MenuRadioGroup.propTypes = _extends({}, stylePropTypes(), {
  name: import_prop_types9.string,
  value: import_prop_types9.any,
  onRadioChange: import_prop_types9.func
}) : void 0;
export {
  ControlledMenu,
  FocusableItem,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuHeader,
  MenuItem,
  MenuRadioGroup,
  SubMenu,
  useMenuState
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=@szhsin_react-menu.js.map
